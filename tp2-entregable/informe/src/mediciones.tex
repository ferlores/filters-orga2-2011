\section{Mediciones}
Para realizar las mediciones utilizamos las herramientas provistas por la c'atedra para la medici'on de ciclos de \textit{clock}. El objetivo ser'a medir los distintos algoritmos, comparando las distintas versiones para distintos tipos de imagenes de entrada. Para ello creamos un conjunto de \textit{scripts} de \textit{bash} que realizas las distintas mediciones que necesitamos. Los mismos se encuentran en la carpeta mediciones junto con una explicacion de como utilizarlo.

\subsection{Estableciendo Criterios}

Antes de comenzar tuvimos que tomar ciertas decisiones de c'omo ibamos a realizar dichas mediciones. El primer problema que encontramos al utilizar el reloj del procesador para medir es que nuestro proceso puede llegar a ser interrumpido por otros procesos o por el sistema operativo. Hemos tomado dos medidas al respecto, la primera es ejecutar las mediciones estableciendo m'axima la priodidad del proceso. Para ello Linux provee el comando \texttt{nice}, que ejecutandolo como \textit{root}, permite decirle al sistema operativo que nuestras mediciones tienen prioridad sobre los otros programas en ejecuci'on. 
Mientras que la segunda medida fue realizar mil mediciones por cada prueba, promediando el resultado. El n'umero elegido aparece como una soluci'on de compromiso con el tiempo de ejecuci'on de las muestras.

Otro factor a analizar fu'e que muestras seleccionamos para medir. Debido a la naturaleza de los algoritmos implementados, podemos ver facilmente que la complejidad esta relacionada directamente con el tama'no de la entrada. Es decir que las dos implementaciones de cada filtro se van a comportar diferente dependiendo del tama'no de la im'agen\footnote{Es importante aclarar que consideramos como tama'no de la imagen, la cantidad total de p'ixeles que esta tiene} y no del tipo de imagen a procesar. Por lo tanto podriamos tomar imagenes de distinto tama'no y comparar como se comportan los distintos filtros y las distintas implementaciones, observando las variaciones de \textit{clocks} con respecto a la cantidad de p'ixeles procesados. Sin embargo elegimos otro camino. Decidimos utilizar un tama'no fijo (dentro de los posible) de p'ixeles y analizar el comportamiento de los algoritmos al variar la relaci'on entre la cantidad de filas y de columnas de la imagen. 

Para las mediciones base utilizamos una imagen de 800x600. Es decir que estamos trabajando con im'agenes de 480.000 p'ixeles (aprox. $0,5Mp$). Luego tomamos distintas ima'genes reacomodando las filas y columnas, seg'un criterios que explicaremos en la siguiente secc'on. Sin embargo a veces no fue posible llegar a la misma cantidad exacta de pixeles. En estos casos elegimos combinaciones donde la diferencia sea m'inima y podemos asegurar que en ningun caso la diferencia de tama'no supera un $0,1\%$ del total.

\subsection{An'alisis de factores}
Antes de decidir las combinaciones de filas y columnas, analizamos con que tipo de im'agenes nuestros algoritmos pod'ian
llegar a comportarse una una manera especial. Como conjetura inicial establecimos que no deberia haber 
fluctuaciones en el las funciones desarrolladas en \C \ ya que el recorrido de la matriz es lineal y
de a un elemento por vez, con lo cual las dimensiones no deber'ian ser un factor relevante. 

En cambio, para el caso de las funciones en \ass, podemos observar que su gran ventaja es que pueden procesar de a muchos datos. Sin embargo su desventaja es que si la imagen no es m'ultiplo de la cantidad de p'ixeles que procesa por iteracion, entonces se debe realizar el reajuste. El mismo que fue expicado en la secci'on \label{sec:ciclos}, con el objetivo de procesar los 'ultimos p'ixeles de la fila reprocesa algunos m'as. 

%\begin{itemize}
% \item{Cantidad de accesos a memoria}.
% \item{Cantidad de instrucciones de movimiento interno de bits en registro}
% \item{Dimensiones de la matriz,(par'ametro de entrada)}
%\end{itemize}
%
%El primer factor pudo subsanarse construyendo un c'odigo m'as eficiente que su version inicial, 
%usando instrucciones y direccionamientos adecuados(que permitieran ganar m'as performance).
%El segundo factor pudo reducirse en gran parte con el uso de m'ascaras, sin embargo en algunos casos
%no se pudieron sacar ya que sin ellos no pod'ia obtenerse la funcionalidad deseada.\\
%El tercer factor esta determinado por la entrada y el algoritmo, se explica en la secci'on siguiente.

Entonces, para elegir exactamente las combinaciones de filas/columnas tene que diferenciar dos tipos de
filtros: Los que toman como par'ametro de entrada im'agenes a color (monocromatizar, separar canales) y los que toman im'agenes en blanco y negro
(umbralizar, invertir, normalizar, suavizar).

Para los que toman imagen en color, en el ciclo principal si bien las lecturas son de 16 bytes se procesa de a 5 pixeles por vez, con lo cual si la cantidad de pixeles de ancho es multiplo de 5 el algoritmo realizar'ia la cantidad justa de lecturas en memoria. En el caso contrario en que la anchura no se multiplo de 5 el algoritmo debe realizar una lectura extra al final de cada fila, con su consecuente procesamiento. Tal vez esto se har'ia para solo procesar un pixel. Es decir, estariamos recalculando 15 bytes para procesar solo uno. Esta diferencia se ver'ia acrecentada si la cantidad de filas es grande, y el costo de esas lecturas extra por columna se har'ia evidente en una eventual medici'on.

%----------------------------------------------------------
% Hasta aca reviso Fer
%----------------------------------------------------------

Teniendo en cuenta esto se decidi'o medir con im'agenes de la siguiente distribuci'on de pixeles:
 \begin{itemize}
 \item{800x600}.
 \item{10x48000}
 \item{11x43636}
\end{itemize}
Para los filtros que trabajan im'agenes blanco y Negro ocurre algo similar a lo anterior solo que cada
pixel esta representado por un byte por lo tanto por cada lectura se procesa de a 16 pixeles. De forma
an'aloga asociamos mejor performance con las im'agenes cuyo anchura en pixeles es un multiplo de 16, y 
una peor performance con las que son coprimas con 16, ya que necesitara una lectura mas por cada columna
de la matriz, mas a'un procesaran algunos datos dos veces. \\
Los \textit{sizes} elegidos para estos caso fueron:\\
\begin{itemize}
 \item{800x600}.
 \item{16x30000}
 \item{17x28235}
\end{itemize}


\subsection{Experimentos}
\subsubsection{Caso base}
En este experimento se miden los siguientes 'indice:
\begin{itemize}
 \item{} \textbf{ciclos}: ciclos de reloj consumidos por cada implementaci'on.
 \item{} \textbf{diferencia de ciclos}: modulo de la diferencia entre ciclos de reloj en \C \ y en \ass.
 \item{} \textbf{porcentaje de mejora}: porcentaje de eficiencia de un implementaci'on con respecto a la otra.
\end{itemize}

Podemos observar que en todos los filtros 
la implementaci'on en \ass \ consume
menos ciclos de reloj, un resultado a que esta dentro de lo esperado, sin embargo llama la atenci'on
lo significativa que es esta diferencia. Por ejemplo en el filtro invertir, que es el que menos instrucciones
realiza, obtuvimos un porcentaje de mejora superior al 96$\%$. El caso del filtro que menos porcentaje
de mejora tuvo fue monocromatizar_uno, que no obstante, obtuvo una mejora superior al 50$\%$. Si bien
suponiamos que podia haber una diferencia en la eficiencia no sabiamos que seria tan marcada, lo cual es muy 
positivo, ya que significa que dio r'editos implementar en un lenguaje de m'as bajo nivel y mayor dificultad
 a cambio de un mejor rendimiento,siempre utilizando la tecnologia \textit{SSE}.\\

\subsubsection{Imagenes altas}
A partir de este exprimento introducimos un nuevo concepto de indice denominado
\textbf{penalizaci'on}. Este 'indice tiene como par'ametros de comparaci'on a los ciclos necesarios por
cada implementaci'on en \ass, mide que porcentaje representa la cantidad de ciclos en un ancho 
favorable con respecto a uno no favorable.

Estudiemos primero el caso de los filtros blanco y negro. Como muestra la tabla a'un existe una 
mejora de \ass  con respecto a \C \  en las dimensiones de 16x30000 y 17x28234. Con esto concluimos que aun
en un caso no favorable es \ass \ sigue siendo m'as eficiente.

Otra observacio'n interesante es el porcentaje de penalizaci'on, notemos que dan 340\%, 165\% y
234\%, para invertir, normalizar y umbralizar respectivamente, estos porcentajes son altos 
y seguramente se debe a lo que dijimos en un principio, que el algoritmo debe reprocesar datos m'as de 
una vez cada vez que itera sobre las 'ultima columnas.

Haciendo un an'alisis similar para el caso color, 
podemos apreciar la diferencia de ciclos en \C \ y \ass \ y su porcentaje de mejora es en todos los casos
alto( mayor a 50\%) y el diferencial es similar en todos los filtros es decir,
la diferencia m'axima entre el porcentaje de caso favorable y caso no favorable es de n 12\% para la funci'on monocromatizar_uno,
el resto se mantiene abajo del 10\%. Un muy buen indicador de rendimiento ya que hay poca diferencia de mejora de
comportamiento entre un caso favorable y otro no favorable.

Para los casos no favorables es de espera que no haya una similitud con respecto al caso base en cuanto a ciclo de 
reloj(implementacion en \ass ), esto se debe al reprocesaiento de datos. Al igual que en el caso de filtro blanco y negro
hay el porcentaje de mejora de ciclos cay'o, conusmiendo mas ciclos en los casos no favorables, si bien esto es una 
oservacion trivial, es un buen indicador de que los casos de prueba fueron bien seleccionados.

Deteng'amonos un momento en los 'indices de penalizaci'on, podemos apreciar que los porcentajes son mucho 
menores con respecto al caso de blanco y negro,lo cual significa que el costo de reprocesar de datos en
las funciones de color fue mucho menor que en dichas funciones,esto seguamente se debe a que los filtros de de color
trabajan con pixeles de 3 bytes cada uno, por lo tanto rerocesa menos pixeles.

Como una observaci'on general de estas mediciones de imagenes altas en contraste con el caso base podemos apreciar la 
similitud en los ciclos de reloj de las implementaciones en \C \ y las diferencias en \ass \ sobre todo en los 
casos no favorables esto se debe a la distribuci'on de los pixeles.

\subsubsection{Imagenes anchas}
Analizemos la tabla de im'agenes anchas, notemos en la tabla \textbf{color alto}, que el porcentaje de mejora es
casi tan alto como el de el caso base, en todos los filtros, esto a simple vista no deber'ia
 sorprendernos pero si observamos m'as atentamente el porcentaje de mejora en los casos desfavorables es 
casi tan alto como en el caso favorable,algo que con \textbf{imagenes altas} no ocurria, por el contrario
deca'ia bastante. Esto es positivo en terminos de performance y probablemente se debe a que si bien
debe reprocesar datos, no son influyentes ya que los aproximadamente 480000 est'an distribuidos en
pocas filas.

Observemos ahora los'indices de penalizaci'on podemos notar que si bien existen (vale decir hay un porcentaje
 de penalizaci'on) este es significativamente menor al de \textbf{imagenes altas} para todos los filtros,esto
deber'ia captar nuesta atenci'on ya que por cada columna en los casos no favorables se reprocesan datos,pero
si lo pensamos dos veces tiene mucho sentido, ya que cuando el ancho era variable, las matrices
tenian m'as filas con lo cual asint'oticamente esa penalizaci'on iria incrementando, ahora las matrices
tienen una cantidad de filas constantes (que encima es comparativamente chica con respecto al ancho),
por lo tanto ese reprocesamiento de datos, si bien no es despreciables, es efectivamente mucho menor
a tal punto de no afectar a la \textit{performance} del filtro.

Como otra observaci'on general notemos que la cantidad de ciclos consumidos por la implementaci'on en \C \ es
similar al de los casos base, por el lado de la implementaci'on en \ass \ en todos los casos salvo normalizar,
los filtros consumen m'as ciclos que en su caso base.

\subsection{Opciones descartadas}
En un momento se penso ver cual era el rendimiento de los algoritmos con una distribuci'on 
aleatoria de im'agenes, pero decidimos omitirla debido a que era muy costosa y no nos 
daria informaci'on valiosa acerca del comportamiento ya que los \textit{sizes} variables pueden comportarse 
de manera an'aloga por la forma de procesar los datos y no habria una diversidad de comportamiento.\\
Se decidio enfocar los casos de prueba en los \textit{sizes} de im'agen y no tanto en el contenido de 
sus pixeles, vale decir no se buscaron especificamente im'agnes con muchos blancos, grises o negros.   


