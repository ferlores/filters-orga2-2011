\section{Mediciones}
Para realizar las mediciones utilizamos las herramientas provistas por la c'atedra para la medici'on de ciclos de \textit{clock}. El objetivo ser'a medir los distintos algoritmos, comparando las distintas versiones para distintos tipos de imagenes de entrada. Para ello creamos un conjunto de \textit{scripts} de \textit{bash} que realizas las distintas mediciones que necesitamos. Los mismos se encuentran en la carpeta mediciones junto con una explicacion de como utilizarlo.

\subsection{Estableciendo Criterios}

Antes de comenzar tuvimos que tomar ciertas decisiones de c'omo ibamos a realizar dichas mediciones. El primer problema que encontramos al utilizar el reloj del procesador para medir es que nuestro proceso puede llegar a ser interrumpido por otros procesos o por el sistema operativo. Hemos tomado dos medidas al respecto, la primera es ejecutar las mediciones estableciendo m'axima la priodidad del proceso. Para ello Linux provee el comando \texttt{nice}, que ejecutandolo como \textit{root}, permite decirle al sistema operativo que nuestras mediciones tienen prioridad sobre los otros programas en ejecuci'on. 
Mientras que la segunda medida fue realizar mil mediciones por cada prueba, promediando el resultado. El n'umero elegido aparece como una soluci'on de compromiso con el tiempo de ejecuci'on de las muestras.

Otro factor a analizar fu'e que muestras seleccionamos para medir. Debido a la naturaleza de los algoritmos implementados, podemos ver facilmente que la complejidad esta relacionada directamente con el tama'no de la entrada. Es decir que las dos implementaciones de cada filtro se van a comportar diferente dependiendo del tama'no de la im'agen\footnote{Es importante aclarar que consideramos como tama'no de la imagen, la cantidad total de p'ixeles que esta tiene} y no del tipo de imagen a procesar. Por lo tanto podriamos tomar imagenes de distinto tama'no y comparar como se comportan los distintos filtros y las distintas implementaciones, observando las variaciones de \textit{clocks} con respecto a la cantidad de p'ixeles procesados. Sin embargo elegimos otro camino. Decidimos utilizar un tama'no fijo (dentro de los posible) de p'ixeles y analizar el comportamiento de los algoritmos al variar la relaci'on entre la cantidad de filas y de columnas de la imagen. 

Para las mediciones base utilizamos una imagen de 800x600. Es decir que estamos trabajando con im'agenes de 480.000 p'ixeles (aprox. $0,5Mp$). Luego tomamos distintas ima'genes reacomodando las filas y columnas, seg'un criterios que explicaremos en la siguiente secc'on. Sin embargo a veces no fue posible llegar a la misma cantidad exacta de pixeles. En estos casos elegimos combinaciones donde la diferencia sea m'inima y podemos asegurar que en ningun caso la diferencia de tama'no supera un $0,1\%$ del total.

\subsection{An'alisis de factores}
Antes de decidir las combinaciones de filas y columnas, analizamos con que tipo de im'agenes nuestros algoritmos pod'ian
llegar a comportarse una una manera especial. Como conjetura inicial establecimos que no deberia haber 
fluctuaciones en el las funciones desarrolladas en \C \ ya que el recorrido de la matriz es lineal y
de a un elemento por vez, con lo cual las dimensiones no deber'ian ser un factor relevante. 

En cambio, para el caso de las funciones en \ass, podemos observar que su gran ventaja es que pueden procesar de a muchos datos. Sin embargo su desventaja es que si la imagen no es m'ultiplo de la cantidad de p'ixeles que procesa por iteracion, entonces se debe realizar el reajuste. El mismo que fue expicado en la secci'on \label{sec:ciclos}, con el objetivo de procesar los 'ultimos p'ixeles de la fila reprocesa algunos m'as. 

%\begin{itemize}
% \item{Cantidad de accesos a memoria}.
% \item{Cantidad de instrucciones de movimiento interno de bits en registro}
% \item{Dimensiones de la matriz,(par'ametro de entrada)}
%\end{itemize}
%
%El primer factor pudo subsanarse construyendo un c'odigo m'as eficiente que su version inicial, 
%usando instrucciones y direccionamientos adecuados(que permitieran ganar m'as performance).
%El segundo factor pudo reducirse en gran parte con el uso de m'ascaras, sin embargo en algunos casos
%no se pudieron sacar ya que sin ellos no pod'ia obtenerse la funcionalidad deseada.\\
%El tercer factor esta determinado por la entrada y el algoritmo, se explica en la secci'on siguiente.

Entonces, para elegir exactamente las combinaciones de filas/columnas tene que diferenciar dos tipos de
filtros: Los que toman como par'ametro de entrada im'agenes a color (monocromatizar, separar canales) y los que toman im'agenes en blanco y negro
(umbralizar, invertir, normalizar, suavizar).

Para los que toman imagen en color, en el ciclo principal si bien las lecturas son de 16 bytes se procesa de a 5 pixeles por vez, con lo cual si la cantidad de pixeles de ancho es multiplo de 5 el algoritmo realizar'ia la cantidad justa de lecturas en memoria. En el caso contrario en que la anchura no se multiplo de 5 el algoritmo debe realizar una lectura extra al final de cada fila, con su consecuente procesamiento. Tal vez esto se har'ia para solo procesar un pixel. Es decir, estariamos recalculando 15 bytes para procesar solo uno. Esta diferencia se ver'ia acrecentada si la cantidad de filas es grande, y el costo de esas lecturas extra por columna se har'ia evidente en una eventual medici'on.

%----------------------------------------------------------
% Hasta aca reviso Fer
%----------------------------------------------------------

Teniendo en cuenta esto se decidi'o medir con im'agenes de la siguiente distribuci'on de pixeles:
 \begin{itemize}
 \item{800x600}.
 \item{10x48000}
 \item{11x43636}
\end{itemize}
Para los filtros que trabajan im'agenes blanco y Negro ocurre algo similar a lo anterior solo que cada
pixel esta representado por un byte por lo tanto por cada lectura se procesa de a 16 pixeles. De forma
an'aloga asociamos mejor performance con las im'agenes cuyo anchura en pixeles es un multiplo de 16, y 
una peor performance con las que son coprimas con 16, ya que necesitara una lectura mas por cada columna
de la matriz, mas a'un procesaran algunos datos dos veces. \\
Los \textit{sizes} elegidos para estos caso fueron:\\
\begin{itemize}
 \item{800x600}.
 \item{16x30000}
 \item{17x28235}
\end{itemize}
\subsection{Analisis de Rendimiento}
Para empezar a entender el an'alisis de rendimiento, es necesario aclarar que tomamos una cantidad
de pixeles fija(480000) y en base a este \textit{size} realizamos las mediciones.
Adem'as pusimos a prueba los casos patol'ogicos de cada algoritmo con distribuciones espec'ificas en
alto y ancho para cada uno, las analizaremos a medida que avance esta secci'on.\\
Como indices comunes analizaremos los :\\
\begin{itemize}
 \item{} \textbf{ciclos}: ciclos de reloj consumidos por cada implementaci'on.
 \item{} \textbf{diferencia de ciclos}: modulo de la diferencia entre ciclos de reloj en \C \ y en \ass.
 \item{} \textbf{porcentaje de mejora}: porcentaje de eficiencia de un implementaci'on con respecto a la otra.
\end{itemize}
%En la primer tabla puede apreciarse el rendimiento en una dimnesion que llamaremos \textbf{caso base} 
Como mencionamos en el inicio de esta secci'on trabajamos con una im'agen de 480000 pixeles, esta vez
distribuidos en 800x600 dimnesion que llamaremos \textbf{caso base}. Podemos observar que en todos los filtros 
la implementaci'on en \ass consume
menos ciclos de reloj, un resultado a que esta dentro de lo esperado, sin embargo llama la atenci'on
lo significativa que es esta diferencia. Por ejemplo en el filtro invertir, que es el que menos instrucciones
realiza, obtuvimos un porcentaje de mejora superior al 96 $\%$. El caso del filtro que menos porcentaje
de mejora tuvo fue monocromatizar_uno que no obstante obtuvo una mejora superior al 50 $\%$. Si bien
suponiamos que podia haber una diferencia en la eficiencia no sabiamos que seria tan marcada, lo cual es muy 
positivo, ya que significa que dio r'editos implementar en un lenguaje de m'as bajo nivel y mayor dificultad
de a cambio de un mejor rendimiento.\\
  
 

\subsection{Opciones descartadas}
En un momento se penso ver cual era el rendimiento de los algoritmos con una distribuci'on 
aleatoria de im'agenes, pero decidimos omitirla debido a que era muy costosa y no nos 
daria informaci'on valiosa acerca del comportamiento ya que los \textit{sizes} variables pueden comportarse 
de manera an'aloga por la forma de procesar los datos y no habria una diversidad de comportamiento.\\
Se decidio enfocar los casos de prueba en los \textit{sizes} de im'agen y no tanto en el contenido de 
sus pixeles, vale decir no se buscaron especificamente im'agnes con muchos blancos, grises o negros.   


