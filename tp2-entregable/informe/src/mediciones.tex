\section{Mediciones}
Para realizar las mediciones utilizamos las herramientas provistas por la c'atedra para la medici'on de ciclos de \textit{clock}. El objetivo ser'a medir los distintos algoritmos, comparando las distintas versiones para distintos tipos de imagenes de entrada. Para ello creamos un conjunto de \textit{scripts} de \textit{bash} que realizas las distintas mediciones que necesitamos. Los mismos se encuentran en la carpeta mediciones junto con una explicacion de como utilizarlo.

\subsection{Estableciendo Criterios}

Antes de comenzar tuvimos que tomar ciertas decisiones de c'omo ibamos a realizar dichas mediciones. El primer problema que encontramos al utilizar el reloj del procesador para medir es que nuestro proceso puede llegar a ser interrumpido por otros procesos o por el sistema operativo. Hemos tomado dos medidas al respecto, la primera es ejecutar las mediciones estableciendo m'axima la priodidad del proceso. Para ello Linux provee el comando \texttt{nice}, que ejecutandolo como \textit{root}, permite decirle al sistema operativo que nuestras mediciones tienen prioridad sobre los otros programas en ejecuci'on. 
Mientras que la segunda medida fue realizar mil mediciones por cada prueba, promediando el resultado. El n'umero elegido aparece como una soluci'on de compromiso con el tiempo de ejecuci'on de las muestras.

Otro factor a analizar fu'e que muestras seleccionamos para medir. Debido a la naturaleza de los algoritmos implementados, podemos ver facilmente que la complejidad esta relacionada directamente con el tama'no de la entrada. Es decir que las dos implementaciones de cada filtro se van a comportar diferente dependiendo del tama'no de la im'agen\footnote{Es importante aclarar que consideramos como tama'no de la imagen, la cantidad total de p'ixeles que esta tiene} y no del tipo de imagen a procesar. Por lo tanto podriamos tomar imagenes de distinto tama'no y comparar como se comportan los distintos filtros y las distintas implementaciones, observando las variaciones de \textit{clocks} con respecto a la cantidad de p'ixeles procesados. Sin embargo elegimos otro camino. Decidimos utilizar un tama'no fijo (dentro de los posible) de p'ixeles y analizar el comportamiento de los algoritmos al variar la relaci'on entre la cantidad de filas y de columnas de la imagen. 

Para las mediciones base utilizamos una imagen de 800x600. Es decir que estamos trabajando con im'agenes de 480.000 p'ixeles (aprox. $0,5Mp$). Luego tomamos distintas ima'genes reacomodando las filas y columnas, seg'un criterios que explicaremos en la siguiente secc'on. Sin embargo a veces no fue posible llegar a la misma cantidad exacta de pixeles. En estos casos elegimos combinaciones donde la diferencia sea m'inima y podemos asegurar que en ningun caso la diferencia de tama'no supera un $0,1\%$ del total.

\subsection{An'alisis de factores}
Antes de decidir las combinaciones de filas y columnas, analizamos con que tipo de im'agenes nuestros algoritmos pod'ian
llegar a comportarse una una manera especial. Como conjetura inicial establecimos que no deberia haber 
fluctuaciones en el las funciones desarrolladas en \C \ ya que el recorrido de la matriz es lineal y
de a un elemento por vez, con lo cual las dimensiones no deber'ian ser un factor relevante. 

En cambio, para el caso de las funciones en \ass, podemos observar que su gran ventaja es que pueden procesar de a muchos datos. Sin embargo su desventaja es que si la imagen no es m'ultiplo de la cantidad de p'ixeles que procesa por iteracion, entonces se debe realizar el reajuste. El mismo que fue expicado en la secci'on \label{sec:ciclos}, con el objetivo de procesar los 'ultimos p'ixeles de la fila reprocesa algunos m'as. 

%\begin{itemize}
% \item{Cantidad de accesos a memoria}.
% \item{Cantidad de instrucciones de movimiento interno de bits en registro}
% \item{Dimensiones de la matriz,(par'ametro de entrada)}
%\end{itemize}
%
%El primer factor pudo subsanarse construyendo un c'odigo m'as eficiente que su version inicial, 
%usando instrucciones y direccionamientos adecuados(que permitieran ganar m'as performance).
%El segundo factor pudo reducirse en gran parte con el uso de m'ascaras, sin embargo en algunos casos
%no se pudieron sacar ya que sin ellos no pod'ia obtenerse la funcionalidad deseada.\\
%El tercer factor esta determinado por la entrada y el algoritmo, se explica en la secci'on siguiente.

Entonces, para elegir exactamente las combinaciones de filas/columnas tene que diferenciar dos tipos de
filtros: Los que toman como par'ametro de entrada im'agenes a color (monocromatizar, separar canales) y los que toman im'agenes en blanco y negro
(umbralizar, invertir, normalizar, suavizar).

Para los que toman imagen en color, en el ciclo principal si bien las lecturas son de 16 bytes se procesa de a 5 pixeles por vez, con lo cual si la cantidad de pixeles de ancho es multiplo de 5 el algoritmo realizar'ia la cantidad justa de lecturas en memoria. En el caso contrario en que la anchura no se multiplo de 5 el algoritmo debe realizar una lectura extra al final de cada fila, con su consecuente procesamiento. Tal vez esto se har'ia para solo procesar un pixel. Es decir, estariamos recalculando 15 bytes para procesar solo uno. Esta diferencia se ver'ia acrecentada si la cantidad de filas es grande, y el costo de esas lecturas extra por columna se har'ia evidente en una eventual medici'on.

%----------------------------------------------------------
% Hasta aca reviso Fer
%----------------------------------------------------------

Teniendo en cuenta esto se decidi'o medir con im'agenes de la siguiente distribuci'on de pixeles:
 \begin{itemize}
 \item{800x600}.
 \item{10x48000}
 \item{11x43636}
\end{itemize}
Para los filtros que trabajan im'agenes blanco y Negro ocurre algo similar a lo anterior solo que cada
pixel esta representado por un byte por lo tanto por cada lectura se procesa de a 16 pixeles. De forma
an'aloga asociamos mejor performance con las im'agenes cuyo anchura en pixeles es un multiplo de 16, y 
una peor performance con las que son coprimas con 16, ya que necesitara una lectura mas por cada columna
de la matriz, mas a'un procesaran algunos datos dos veces. \\
Los \textit{sizes} elegidos para estos caso fueron:\\
\begin{itemize}
 \item{800x600}.
 \item{16x30000}
 \item{17x28235}
\end{itemize}
\subsection{Analisis de Rendimiento}
Para empezar a entender el an'alisis de rendimiento, es necesario aclarar que tomamos una cantidad
de pixeles fija(480000) y en base a este \textit{size} realizamos las mediciones.
Adem'as pusimos a prueba los casos patol'ogicos de cada algoritmo con distribuciones espec'ificas en
alto y ancho para cada uno, las analizaremos a medida que avance esta secci'on.\\
Como indices comunes analizaremos los :\\
\begin{itemize}
 \item{} \textbf{ciclos}: ciclos de reloj consumidos por cada implementaci'on.
 \item{} \textbf{diferencia de ciclos}: modulo de la diferencia entre ciclos de reloj en \C \ y en \ass.
 \item{} \textbf{porcentaje de mejora}: porcentaje de eficiencia de un implementaci'on con respecto a la otra.
\end{itemize}
%En la primer tabla puede apreciarse el rendimiento en una dimnesion que llamaremos \textbf{caso base} 
Como mencionamos en el inicio de esta secci'on trabajamos con una im'agen de 480000 pixeles, esta vez
distribuidos en 800x600 dimnesion que llamaremos \textbf{caso base}. Podemos observar que en todos los filtros 
la implementaci'on en \ass \ consume
menos ciclos de reloj, un resultado a que esta dentro de lo esperado, sin embargo llama la atenci'on
lo significativa que es esta diferencia. Por ejemplo en el filtro invertir, que es el que menos instrucciones
realiza, obtuvimos un porcentaje de mejora superior al 96 $\%$. El caso del filtro que menos porcentaje
de mejora tuvo fue monocromatizar_uno que no obstante obtuvo una mejora superior al 50 $\%$. Si bien
suponiamos que podia haber una diferencia en la eficiencia no sabiamos que seria tan marcada, lo cual es muy 
positivo, ya que significa que dio r'editos implementar en un lenguaje de m'as bajo nivel y mayor dificultad
de a cambio de un mejor rendimiento.\\
\subsection{Casos no estandar}
En esta secci'on analizaremos los rendimientos de los filtros en imagenes de la misma cantidad de pixeles que antes
o aproximadamente la misma, pero con anchos y altos especi'ficos que afectan al rendimiento de cada funci'on.\\
A su vez diferenciamos dos tipos de filtros \textbf{Blanco y negro} y \textbf{color}, si bien
son clasificaciones ortogonales el caso ancho pudimos expresarlo en una sola tabla ya que encontramos
un ancho que sea multiplo de 10 pixeles y a su vez de 16, que sirve tanto para las imagenes color como
para las blanco y negro. Como notaci'on diremos que que un ancho es \textbf{favorable} a un filtro si es
 multiplo de la cantidad de pixeles que procesa por lectura a memoria, y no \textbf{no favorable}
si es coprima con esta.\\    
Vale aclarar tambi'en que el procesamiento de datos usando tenconolgia \textit{sse} es una ventaja, pero 
podr'ia no llegar a serlo de esa manera, si el ancho en pixiles de la matriz no es favorable, es decir
debo reprocesar  algunos datos m'as de una vez por cada ciclo en que recorro las columnas, es por eso 
que agregamos un nuevo 'indice de medicion al que denominaremos 
\textbf{penalizaci'on}.Este 'indice tiene como par'ametros de comparaci'on a los ciclos necesarios por
cada implementaci'on en \ass, mide que porcentaje representa la cantidad de ciclos en un ancho 
favorable con respecto a uno no favorable. Aclarado esto comenzemos con el analisis de rendimiento 
con las distintas clasificaciones de criterios.
\subsubsection{Caso alto variable}
En esta secci'on vamos a analizar rendimientos para cada filtro donde el ancho es favorable y cuando no.\\
Estudiemos primero el caso de los filtros blanco y negro. Como muestra la tabla a'un existe una 
concordancia entre el porcentaje de mejora en las dimensiones de 16x30000 y 17x28234, m'as a'un 
en el caso favorable ese 'indice de mejora permaneci'o con respecto al caso base. En el ancho
no favorable el porcentaje de mejora fue menor, pero aun asi superior al 70\% en todos los casos.
Esto probablemnte se deba a que la implementaci'on en \C \ al recorrer linealmente no es un factor
determinante si al ancho es favorable o no, mas bien con todos los anchos es lo mismo.\\
Otra observacio'n interesante es el porcentaje de penalizaci'on, notemos que dan 340\%, 165\% y
234\%, para invertir, normalizar y umbralizar respectivamente, estos porcentajes son altos 
y seguramente se debe a lo que dijimos en un principio, que el algoritmo de reprocesar datos m'as de 
una vez.\\%El unico caso donde esto no ocurre es el suavizado probablemente haya que tratarlo con
%\textit{suavidad} cuak!. \\
Haciendo un an'alisis similar para el caso color, establecemos las dimensiones de 10x48000 y 11x43636
como casos favorables y no favorables respectivamente. \\
Podemos apreciar la diferencia de ciclos en \C \ y \ass \ y su porcentaje de mejora es en todos los casos
alto( mayor a 50\%) y con casi la misma regularidad en cuanto al porcentaje en los casos favorables.
Con el caso no favorable el resultado es an'alogo al del parrafo anterior no hay una regularidad con respecto 
al caso base y eso se debe a la iteracion lineal del algoritmo en \C,\ la diferencia de 
casos favorables contra no favorables entre porcentajes
de mejora supera el 10\% en todos los casos(tanto blanco y negro como color), si bien esto no es muy 
interesante y sale trivialmente de observar la tabla es un indicador de que los casos de prueba estuvieron
 bien seleccionados.\\
Detengamonos un momento en los indices de penalizaci'on, podemos apreciar que los porcentajes son mucho 
menores con respecto al caso de blanco y negro,lo cual significa que el costo de reprocesar de datos en
las funciones de color fue mucho menor que en las funciones de blanco y negro.\\
\subsubsection{Ancho variable}
Como mencionamos en el inicio de la secci'on principal,logramos conseguir una cota paa el ancho que sea
multiplo de 16 pixeles y de 10 a la vez para no tener que discriminar entre los filtros de blanco-negro
y color, a su vez deb'iamos mantener una constante de pixeles lo mas aproximada a 480000, 
teniendo im'agenes lo m'as anchas posibles, finalmente elegimos casos de 1441x333 y 1440x333 como no 
favorables y favorables respectivamente. \textquestiondown Porque 1440x333 ? Esto se debe como dijimos antes a que no es 
coprimo ni con 10 ni con 16,pero adem'a no pudimos elegir un ancho mas grande ya que la libreria openCV
nos premite operar con buffer de hasta 1456 pixeles de ancho, luego de esto genera un error de memoria, y
el pr'oximo n'umero n que cumple n $\equiv$ 0 (10) y n $\equiv$ 0 (16) es mayor a 1456, para ver esto hay que resolver 
aplicar el teorema chino del resto, pero esa cuenta no aparecer'a en este informe.\\
Volviendo al an'alisis, notemos en la tabla \textbf{color alto}, que el porcentaje de mejora es
casi tan alto como el de el caso base, en todos los filtros, esto a simple vista no deber'ia
 sorprendernos pero si observemos m'as atentamente el porcentaje de mejora en los casos desfavorables es 
casi tan alto como en el caso favorable,algo que con \textbf{alto variables} no ocurria, por el contrario
decaia bastante. Esto es positivo en terminos de performance y probablemente se debe a que si bien
debe reprocesar datos, no son influyente ya que los aproximadamente 480000  est'an distribuidos en
pocas filas.\\
Observemos ahora los'indices de penalizaci'on podemos notar que si bien existen (vale decir hay un porcentaje
 de penalizaci'on es significativamente menor al de \textbf{alto variable} para todos los filtros,esto
deber'ia captar nuesta atenci'on ya que por cada columna en los casos no favorables se reprocesan datos,pero
si lo pensamos dos veces tiene mucho sentido, ya que cuando el ancho era variable, las matrices
tenian m'as filas con lo cual asint'oticamente esa penalizaci'on iria incrementando, ahora las matrices
tiene una cantida de filas constantes (que encima es comparativamente chica con respecto al ancho),
por lo tanto ese reprocesamiento de datos, si bien no es despreciables, es efectivamente muchisimo menor
a tal punto de no afectar a la \textit{performance} del filtro.\\

   



\subsection{Opciones descartadas}
En un momento se penso ver cual era el rendimiento de los algoritmos con una distribuci'on 
aleatoria de im'agenes, pero decidimos omitirla debido a que era muy costosa y no nos 
daria informaci'on valiosa acerca del comportamiento ya que los \textit{sizes} variables pueden comportarse 
de manera an'aloga por la forma de procesar los datos y no habria una diversidad de comportamiento.\\
Se decidio enfocar los casos de prueba en los \textit{sizes} de im'agen y no tanto en el contenido de 
sus pixeles, vale decir no se buscaron especificamente im'agnes con muchos blancos, grises o negros.   


