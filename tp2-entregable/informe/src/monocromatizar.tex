\subsection{Monocromatizar}
\subsubsection{Monocromatizar $\epsilon = 1$ }
El objetivo de la funcion monocromatizar es convertir una imagen a escala de grises, en la imagen fuente
cada pixel se compone de 3 bytes,uno por cada componente de color \textbf{RGB}. En su respectiva implementacion en 
\newcolumntype{C} la imagen se recorre linealmente como  una matriz guardando los valor de cada componente de color
que tiene los pixeles y aplic'andole una serie de operaciones que es la siguiente:
\textbf{(R+2*G+B)/4}, finalmente esto es lo que se almacena en la imagen destino.\\
La idea en \_asm es similar solo que, aprovechando la capacidad de almacenamiento de los registro de 128 bits
y teniendo en cuanta que en cada uno de estos registro entran 16 bytes podemos procesar de hasta 5 pixeles
por iteracion, en lugar de 1.
Inicialmete cuando leemos en memoria de la imagen fuente, cargamos 16 bytes en un registro de xmm dejando 
las componentes de color de la siguiente manera: \\
\begin{figure}[hb]
\xmmW{texto}{B_5R_4 & G_4B_4 & R_3G_3 & B_3R_2 & G_2B_2 & R_1G_1 & B_1R_0 & G_0B_0}
%\xmmD{texto}{0G_2 0B_2 & R_1G_1 & B_1R_0 & G_0B_0}
\caption{como se levanta de memoria normalizar\_asm}
\label{est:m-uno}
\end{figure}
Como puede observarse se levanta un tercio del sexto pixel, si bien esto no nos preocupa ya que procesaremos
hasta el quinto, debemos reacomodar los datos para poder realizar el copiado de manera c'omoda, pero
antes debemos realizar los c'alculos necesarios. Para reacomodarlos  copiamos en otro registros
lo leido en memoria y los corrimos de manera conveniente como muestra la figura: \\
\begin{figure}[hb]
\xmmW{xmm0}{B_5R_4 & G_4B_4 & R_3G_3 & B_3R_2 & G_2B_2 & R_1G_1 & B_1R_0 & G_0B_0}
\xmmW{xmm1}{ 0B_5&R_4G_4 & B_4R_3 & G_3B_3 & R_2G_2 & B_2R_1 & G_1B_1 & R_0G_0}
\xmmW{xmm2}{ 00 & B_5R_4 & G_4B_4 & R_3G_3 & B_3R_2 & G_2B_2 & R_1G_1 & B_1R_0}
%\xmmD{texto}{0G_2 0B_2 & R_1G_1 & B_1R_0 & G_0B_0}
\caption{como se corren los datos de manera favorable}
\label{est:m-uno}
\end{figure}

Tras analizar distintas opciones llegamos a la conclusion de
que no es posible  hacer las cuentas sin antes desempaquetar los datos ya que de lo contrario se perderia
presici'on o  podria saturar alguna suma, no obstante dado que la division por 4 es la 'ultima operacion que se
aplica el resultado final es expresable en un byte. Teniendo en cuanta eso procedimosde la siguiente manera: 
Por cada uno de los registro mencionados desempaquetamos tomando como segundo operando un registro de 128
bits con ceros, y los dividimos en partes bajas y altas, como muestra la figura: \\
\begin{figure}[hb]
\xmmW{xmm}{ 0_0G_2  & 0_0B_2 & 0_0R_1 & 0_0G_1 & 0_0B_1 & 0_0R_0 & 00G_0 & 00B_0}
\xmmW{xmm}{ 00 B_5  & 00 R_4 & 00 G_4 & 00B_4 & 00 R_3 & 00 G_3 & 00 B_3 & 00 R_2}
\caption{desempaquetado}
\label{est:m-uno}
\end{figure}
Para multiplicar y dividir usamos las instrucciones \textit{psrlw} y \textit{psllw} para realizar un corrimiento 
de bits s derechar e izquierda respectivamente en cada word del registro. \\
Una vez realizados los c'alculos necesarios notemos que tenesmo las cuentas necesarias en dos registros
y separadas cada dos bytes con lo cual debemos procedes a unirlos para luego copiarlos. \\
El proceso para unirlos consiste en dos partes, una es aplicar una m'ascara debido a que no podemos 
fiarnos del contenido de los bytes que saparan cada dato que necesitamos, esa m'ascara tendra unos 
y ceros ya que al aplicarle \textit{pand} me quedan los datos necesarios separados por ceros.\\
La otra parte consites en sumarlos una vez aplicada la mascara y utiliar las instruciones que provee
la arquitectura para correr bytes y dwords dentro de un registro( \textit{pshuflw},\textit{pshufhw},
\textit{pshufd}) para colocarlos de manera contigua en dos registros y luego enpaquetar. Si bien 
estas instrucciones pueden afectar la performance son realmente de 'utiles e
indispensables para obtener la funcionalidad deseada.
Una ves terminado este proceso, copiamos un \textit{dword} a memoria y con eso cubrimos 4 pixeles,
luego hacemos un corrimiento del registro donde tenemos guardados los datos ya calculados para luego,
copiar el quinto pixel restante, incrementamos los punteros adecuadamente para continuar el 
proceso en las proximas iteraciones.\\


\subsubsection{Monocromatizar $\epsilon = \infty $ }
El objetivo de esta funcion es similar al anterior, solo que esta vez en lugar de aplicar operaciones
una ves acomodados los datos solo debemos obtener el maximo.\\
En un principio el procedimiento es similar al de  $\epsilon= 1$, es decir leemos de memoria 16 bytes
y realizamos copias de esa lectura en otros registro para correrlos adecuadamente y operar. Ahora bien, 
notemos contamos con una ventaja con respecto al caso anterior y es que no necesitamos desenpaquetar
ya que no realizamos operaciones de ningun tipo que puedan resultar en una saturaci'on o 
resultado erroneo,mas bien nos piden la maxima componente de color de cada pixel. Luego de analizar 
varias opciones utilizando m'ascaras de bits, o cuentas auxliliares optamos por utilizar la instrucciones
\textit{pmaxub} que calcula en laximo byte a byte entre dos registros xmm, esto no solo facilita 
el desarrollo sino que adem'as incrementa la performance ya que esta provista por la arquitectura y 
esta optimizada.\\
Una vez obtenido los maximos  de cada pixel(solo nos interesan 5 de ellos), debemos concentrarnos en
tenerlos en un registro de proposito general de manera contigua. 
Entonces partiendo de que tenemos un registro con los maximos calculados de la siguiente manera:
\\
%meter espacio para figura
Copiamo este registro en otro ya que operaremos con ambos y podesmo perder ciertos datos. Realizamos un 
corrimiento de 8 bits a izquierda en cada word para obtener ceros a la izquierda de cada una de las partes bajas de
cada word. En la otra copia hacemos algo parecido solo que hacemos un coriimiento a derecha y luego a izquierda
dejando los registros de la siguiente manera: \\
%insertar figura
Una vez logrado esto debemos proceder a deshacernos de los bytes que no sabemos que contienen y separan
cada uno de los maximos, para ello los transformamos en ceros con una m'ascara y luego los sumamos,
asi obtenemos los maximos en un solo registro( aunque esten desordenados).\\
Nuevamente ordenamos los contenidos de los registros utilizando las instrucciones de coorimiento de bits
dentro de un registro mencionadas en la funcion anterior y de forma an'aloga realizamos el porceso de copiado a la imagen destino.






 
 

