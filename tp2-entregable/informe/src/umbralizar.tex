\subsection{Umbralizar}
Este filtro proproduce im'agenes con solamente tres colores (blanco, gris y negro), dependiendo del valor que tenga cada p'ixel.
El procesamiento de cada p'ixel esta definido por la siguiente funci'on:

$$I_{out}(p) = \left\{\begin{array}{lcc} 0 & \text{si } p \leq umbralMin\\  128 & \text{si } umbralMin < p \leq umbralMax \\ 255 & \text{si } p > umbralMax \end{array} \right. $$

La implementaci'on en \C\ es nuevamente trival. Recorremos, como siempre en estos casos, secuencialmente de a un byte mientras que el procesamiento de cada p'ixel se reduce a dos comparaciones para elegir el valor correcto del resultado.

En cambio, para la implementaci'on en \ass\ tenemos varios pasos. Primero vimos que para realizar las comparaciones era necesario tener los umbrales empaquetados en los registros de 128 bits. Para esto cargamos los valores que recibimos como par'ametro de entrada en un registro de proposito general. Luego realizamos desplazamientos de a de 8 bits a la izquierda y sucesivas sumas del valor hasta que conseguimos un doble word lleno. Despues movemos a dos registros de 128 bits el registro de prop'osito general con el umbral m'inimo y m'aximo y utilizamos la instruccion de intercambio \textit{shufle} de double words para replicar el valor a lo largo de todo el registro SSE.

Por otro lado necesitabamos una m'ascara donde est'e el numero 128, que representa el gris en la im'agen.
Para lo cual primero colocamos el numero 128 repetido 4 veces en un registro de proposito general,  
este es definido en notacion hexadecimal como 80h. Luego colocamos este en el registro xmm6 y con la operacion 
\textit{pshufd},repetimos este elemento en todas las otras \textit{double words} dentro del registro.
El resultado de este proceso se ve en la figura \ref{est:u-uno}.

\begin{figure}[h!]
\xmmW{paso 5}{Umin & Umin & Umin & Umin & Umin & Umin & Umin & Umin}
\xmmW{paso 4}{Umax & Umax & Umax & Umax & Umax & Umax & Umax & Umax}
\xmmW{paso 6}{128 & 128 & 128 & 128 & 128 & 128 & 128 & 128}
\caption{???????????????????????????????}
\label{est:u-uno}
\end{figure}

Una vez ya definidos los umbrales en los registros comenzamos a procesar los datos, primero levantamos la linea 
en el registro xmm0, copiamos la m'ascara del umbral m'aximo en xmm3 y para saber cuales eran los elementos que estaban
sobre el umbral restamos y saturamos a la copia del umbral el valor que tenemos en la linea de los p'ixeles leidos y con 
la instrucci'on \textit{pcmpeqb} contra un registro vacio, nos quedan los n'umeros hexadecimales F en las posiciones donde es igual a cero, 
esto quiere decir que el umbral m'aximo en esas posiciones es superior al valor que se tiene en la imagen, quedandonos F 
en las pociones que estan sobre el umbral en el registro xmm3.

Siguiente a esto realizamos la diferencia saturada entre los valores en los p'ixeles de la im'agen y un registro que tiene 
el umbral m'inimo, con lo cual nos quedan ceros en los bytes que estan debajo del umbral m'inimo gracias a la saturacion,
y con la instrucci'on \textit{pcmpeqb} nos queda una F en los bytes que estan debajo del umbral en el registro xmm0.
Luego realizamos un OR con los dos registros calculados (xmm0, xmm3) y al resultado le aplicamos la instrucci'on \textit{pcmpeqb} con
un registro vacio para obtener F donde haya ceros, de esta manera esas F representan los p'ixeles que se encuentran en el 
medio del umbral.

Luego se le aplica la operacion AND a el resultado con la m'ascara, y se obtiene el valor que implicar'ia los grises.
De esta manera nos queda el valor 128 en las pociones intermedias del umbral, y al realizarle la operaci'on OR con el registro 
xmm3 que contiene los extremos superiores obtenemos 255 que representa el blanco en las posiciones que est'an sobre el umbral 
m'aximo, una vez realizado esto procedemos a guardar el dato.